/*
 * @lc app=leetcode.cn id=53 lang=c
 *
 * [53] 最大子序和
 * 
 

int main() {
    int nums[100] = {-84,-87,-78,-16,-94,-36,-87,-93,-50,-22,-63,-28,-91,-60,-64,-27,-41,-27,-73,-37,-12,-69,-68,-30,-83,-31,-63,-24,-68,-36,-30,-3,-23,-59,-70,-68,-94,-57,-12,-43,-30,-74,-22,-20,-85,-38,-99,-25,-16,-71,-14,-27,-92,-81,-57,-74,-63,-71,-97,-82,-6,-26,-85,-28,-37,-6,-47,-30,-14,-58,-25,-96,-83,-46,-15,-68,-35,-65,-44,-51,-88,-9,-77,-79,-89,-85,-4,-52,-55,-100,-33,-61,-77,-69,-40,-13,-27,-87,-95,-40};
    int rs = maxSubArray(nums, 100);
    printf("rs:%d", rs);
}
*/

int maxSubArray(int* nums, int numsSize){
    if (numsSize == 0) {
        return 0;
    }
    // 先把第一个数 当结果
    int result = nums[0];
    int tmpsum = 0;

    //if (numsSize == 1)        return nums[0];
    for (int i = 0; i < numsSize; i++)
    {
        // 如果临时和 大于> 则和当前的值 相加。 否则就用当前的值替换临时和
        if (tmpsum > 0) {
            tmpsum +=  nums[i];
        } else {
            tmpsum = nums[i];
        }

        // 如果临时的和 > 最终的和 则替换
        if (tmpsum > result) {
            result = tmpsum;
        }
    }
    return result;
}


